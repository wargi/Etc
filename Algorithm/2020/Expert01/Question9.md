# 세 형제의 식사

## 1. 문제
- 매 3형제가 먹이를 찾아 배열 위를 돌아다니고 있습니다.
  1번 매는 0 ~ 2번 index, 2번 매는 3 ~ 5번 index를, 3번 매는 1 ~ 4번 index 위로 비행합니다.

```
3 7 4 2 6 9
```

- 각 배열의 숫자들은 먹이의 크기입니다.
- 매는 비행 범위 내, 배열 중 한 칸을 정해 땅으로 내려와 먹이를 먹습니다.
- 먹이를 먹고난 뒤, 먹이의 크기는 0 이 됩니다.
- **매 삼 형제의 식사 규칙**
  1. 한 턴에 1번 > 2번 > 3번 순서대로 먹이를 먹습니다.
  2. 각 독수리는 음식이 있는 곳에 내려오게되면, 그 칸에 있는 음식을 모두 먹게 되지만, 음식이 없는 곳에 내려오면 (이미 음식을 먹은 곳) 아무것도 먹지 못하고 턴이 넘어갑니다.
- **먹이의 증식 규칙**
  1. 1, 2, 3번 독수리가 식사를 한번씩 끝내면 한 턴이 끝납니다.
  2. 한 턴이 지날때 마다, 살아있는 먹이들은 크기가 2배가 됩니다.

```
ex)
2회 식사할 예정이며, 3 7 4 2 6 9 로 입력받는 경우
첫 번째 식사 : [3] 7 [4] [2] 6 9
식사 후 : 0 7 0 0 6 9
증식 후 : 0 14 0 0 12 18
두 번째 식사 : 0 [14] 0 0 [12] [18]

총 식사량 : 3 + 4 + 2 + 14 + 12 + 18 = 53
```

## 2. 입력
- 총 일곱 칸의 먹이의 크기를 입력받고, 식사를 할 횟수(턴)을 입력받으세요.
- 먹이가 되는 7개의 수 입력 (1 <= 먹이 크기 <= 10,000)
- 식사의 횟수 (1 <= 턴 <= 3)

## 3. 출력
- 독수리 3형제가 먹을수 있는 먹이 크기 합 중 최대 값을 출력 해주세요.

## 4. 예제 입력
```
3 7 4 2 6 9
2
```

## 5. 예제 출력
```
53
```

## 6. 코드

```c++
#include <iostream>
using namespace std;

int vect[6] = { 3, 7, 4, 2, 6, 9 };
int check[3] = { 0 };
int used[6] = { 0 };
int maxi = -21e8;

void run(int level, int sum) {
    if (level == 3) {
        if (maxi < sum) maxi = sum;
        return;
    }

    if (!check[0]) {
        check[0] = 1;
        for (int i = 0; i < 2; i++) {
            if (used[i]) continue;
            used[i] = 1;
            run(level + 1, sum + vect[i]);
            used[i] = 0;
        }
        check[0] = 0;
    }
    if (!check[1]) {
        check[1] = 1;
        for (int i = 3; i < 6; i++) {
            if (used[i]) continue;
            used[i] = 1;
            run(level + 1, sum + vect[i]);
            used[i] = 0;
        }
        check[1] = 0;
    }
    if (!check[2]) {
        check[0] = 1;
        for (int i = 1; i < 5; i++) {
            if (used[i]) continue;
            used[i] = 1;
            run(level + 1, sum + vect[i]);
            used[i] = 0;
        }
        check[2] = 0;
    }
}

int main()
{
    run(0, 0);

    cout << maxi;

    return 0;
}
```
