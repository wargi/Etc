# 범인 추적하기

## 1. 문제

- 제보받은 인덱스(입력)부터 범인을 추적합니다.
- 범인이 남긴 발자취를 추적하고, 범인이 있는 곳까지 도달하게 됩니다.
- 아래의 발자취 배열(2x7)을 하드코딩 해주세요.

```
[발자취 배열]
3 2 1 3 2 -1 1
1 1 0 1 0 -1 0

[배열 설명]
0행: 이동 거리(-1: 범인이 있는 위치)
1행: 이동 방향(0: 왼쪽, 1: 오른쪽)

[예제]
* 예를 들어 2번 인덱스부터 추적을 시작하는 경우,
* 왼쪽으로 한 칸 이동하고 ([1번] 도착)
* 오른쪽으로 두 칸 이동하고 ([3번] 도착)
* 오른쪽으로 세 칸 이동하고 ([6번] 도착)
* 다시 왼쪽으로 한 칸 이동하여 테러범을 만날 수 있습니다. ([5번] 도착)

[출력 방법]
- 범인을 찾았다면 탐색한 경로를 역순으로 출력해주세요.
* 위의 예시 출력결과 : 5번 > 6번 > 3번 > 1번 > 2번
```

## 2. 입력

- 추적 시작할 위치 인덱스 번호를 입력받아주세요. (0 <= n <= 6)

## 3. 출력

- 범인을 찾았다면 탐색한 경로를 역순으로 출력해주세요.

## 4. 예제 입력

```
2
```

## 5. 예제 출력
```
5번
6번
3번
1번
2번
```

## 6. 코드
```c++
#include <iostream>
#include <string>
using namespace std;

struct Node {
    int move;
    char dir;
};

Node map[7] = { { 3, 'R'}, { 2, 'R'}, { 1, 'L'}, { 3, 'R'}, { 2, 'L'}, { -1, 'O'}, { 1, 'L'} };

void run(int idx) {
    if (map[idx].move == -1) {
        cout << idx << "번\n";
        return;
    }

    if (map[idx].dir == 'L') run(idx - map[idx].move);
    else run(idx + map[idx].move);

    cout << idx << "번\n";
}

int main()
{
    int n;
    cin >> n;

    run(n);

    return 0;
}
```
